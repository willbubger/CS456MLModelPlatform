<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Model Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.11.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1400px;
            width: 95%;
            max-height: 95vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .login-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 400px;
            width: 90%;
        }

        .login-container h1 {
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 600;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
            margin-top: 10px;
        }

        .btn-secondary:hover {
            background: #f0f4ff;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
        }

        .header-actions {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .nav-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            padding: 8px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        .nav-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .nav-btn.active {
            background: white;
            color: #667eea;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #e0e0e0;
        }

        .content-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #e0e0e0;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .file-upload {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload:hover {
            background: #f0f4ff;
            border-color: #764ba2;
        }

        .file-upload input {
            display: none;
        }

        .model-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .model-card {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .model-card:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .model-card.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .metric-card h3 {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .metric-card .value {
            font-size: 32px;
            font-weight: bold;
        }

        .chart-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #e0e0e0;
        }

        canvas {
            max-height: 400px;
        }

        .hidden {
            display: none !important;
        }

        .dataset-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .dataset-info p {
            margin: 5px 0;
            color: #333;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .nn-config {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .nn-config input {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            margin: 5px 0;
        }

        .error {
            color: #e74c3c;
            background: #ffeaea;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .success {
            color: #27ae60;
            background: #eafff0;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .spinner {
            width: 80px;
            height: 80px;
            margin: 0 auto 30px;
            border: 8px solid #f3f3f3;
            border-top: 8px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-content h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 24px;
        }

        .loading-content p {
            color: #666;
            font-size: 16px;
            margin-bottom: 20px;
        }

        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }

        .loading-status {
            margin-top: 15px;
            color: #667eea;
            font-weight: 600;
            font-size: 14px;
        }

        .history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .history-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
        }

        .history-card:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .history-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .history-card-title {
            color: #667eea;
            font-size: 18px;
            font-weight: 600;
        }

        .history-card-date {
            color: #999;
            font-size: 12px;
        }

        .history-card-info {
            margin-bottom: 10px;
            color: #666;
            font-size: 14px;
        }

        .history-card-models {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .history-model-badge {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .history-card-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .history-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
        }

        .view-btn {
            background: #667eea;
            color: white;
        }

        .view-btn:hover {
            background: #5568d3;
        }

        .delete-btn {
            background: #e74c3c;
            color: white;
        }

        .delete-btn:hover {
            background: #c0392b;
        }

        .empty-history {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-history-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .empty-history h3 {
            color: #666;
            margin-bottom: 10px;
        }

        .toggle-text {
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 14px;
        }

        .toggle-link {
            color: #667eea;
            cursor: pointer;
            font-weight: 600;
            text-decoration: underline;
        }

        .toggle-link:hover {
            color: #764ba2;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-container">
        <h1>ü§ñ ML Model Platform</h1>
        
        <!-- Login Form -->
        <div id="loginForm">
            <div class="form-group">
                <label>Username</label>
                <input type="text" id="loginUsername" placeholder="Enter username">
            </div>
            <div class="form-group">
                <label>Password</label>
                <input type="password" id="loginPassword" placeholder="Enter password">
            </div>
            <div id="loginError" class="error hidden"></div>
            <button class="btn" onclick="login()">Login</button>
            <button class="btn btn-secondary" onclick="showSignup()">Create Account</button>
        </div>

        <!-- Signup Form -->
        <div id="signupForm" class="hidden">
            <div class="form-group">
                <label>Username</label>
                <input type="text" id="signupUsername" placeholder="Choose username (min 3 characters)">
            </div>
            <div class="form-group">
                <label>Password</label>
                <input type="password" id="signupPassword" placeholder="Choose password (min 6 characters)">
            </div>
            <div class="form-group">
                <label>Confirm Password</label>
                <input type="password" id="signupConfirmPassword" placeholder="Confirm password">
            </div>
            <div id="signupError" class="error hidden"></div>
            <div id="signupSuccess" class="success hidden"></div>
            <button class="btn" onclick="signup()">Create Account</button>
            <button class="btn btn-secondary" onclick="showLogin()">Back to Login</button>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-overlay hidden">
        <div class="loading-content">
            <div class="spinner"></div>
            <h2>Training Models</h2>
            <p>Please wait while we train your machine learning models...</p>
            <div class="progress-bar-container">
                <div class="progress-bar" id="trainingProgress">0%</div>
            </div>
            <div class="loading-status" id="loadingStatus">Initializing...</div>
        </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="container hidden">
        <div class="header">
            <h1>ü§ñ ML Model Platform</h1>
            <div class="header-actions">
                <button class="nav-btn active" id="trainNavBtn" onclick="showScreen('train')">Train Models</button>
                <button class="nav-btn" id="historyNavBtn" onclick="showScreen('history')">History</button>
                <span id="userDisplay" style="margin-left: 10px;"></span>
                <button class="nav-btn" onclick="logout()">Logout</button>
            </div>
        </div>

        <div class="main-content">
            <!-- Training Screen -->
            <div id="trainScreen" class="main-content" style="width: 100%;">
                <div class="sidebar">
                    <div class="section">
                        <h2>üìÅ Upload Dataset</h2>
                        <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                            <p>üì§ Click to upload</p>
                            <p style="font-size: 12px; color: #666; margin-top: 5px;">
                                Supports .txt, .csv, .xlsx
                            </p>
                            <input type="file" id="fileInput" accept=".txt,.csv,.xlsx" onchange="handleFileUpload(event)">
                        </div>
                        <div id="datasetInfo" class="hidden"></div>
                    </div>

                    <div class="section">
                        <h2>üéØ Select Target Variable</h2>
                        <select id="targetSelect" onchange="updateTargetVariable()">
                            <option value="">Select target column</option>
                        </select>
                    </div>

                    <div class="section">
                        <h2>üß† Select Models</h2>
                        <div class="model-grid">
                            <div class="model-card" data-model="linear" onclick="toggleModel(this)">
                                Linear Regression
                            </div>
                            <div class="model-card" data-model="logistic" onclick="toggleModel(this)">
                                Logistic Regression
                            </div>
                            <div class="model-card" data-model="decision" onclick="toggleModel(this)">
                                Decision Tree
                            </div>
                            <div class="model-card" data-model="randomforest" onclick="toggleModel(this)">
                                Random Forest
                            </div>
                            <div class="model-card" data-model="svm" onclick="toggleModel(this)">
                                SVM
                            </div>
                            <div class="model-card" data-model="nn" onclick="toggleModel(this)">
                                Neural Network
                            </div>
                        </div>

                        <div id="nnConfig" class="nn-config hidden">
                            <h3>Neural Network Config</h3>
                            <label>Hidden Layers (comma-separated)</label>
                            <input type="text" id="nnLayers" value="64,32" placeholder="e.g., 64,32,16">
                            <label>Epochs</label>
                            <input type="number" id="nnEpochs" value="50" min="1">
                            <label>Learning Rate</label>
                            <input type="number" id="nnLR" value="0.01" step="0.001" min="0.001">
                        </div>
                    </div>

                    <div class="section">
                        <button class="btn" onclick="trainModels()" id="trainBtn" disabled>
                            üöÄ Train Models
                        </button>
                    </div>
                </div>

                <div class="content-area">
                    <div id="resultsSection" class="hidden">
                        <h2 style="color: #667eea; margin-bottom: 20px;">üìä Results</h2>
                        
                        <div id="metricsGrid" class="results-grid"></div>
                        
                        <div class="chart-container">
                            <h3>Model Comparison</h3>
                            <canvas id="comparisonChart"></canvas>
                        </div>

                        <div class="chart-container">
                            <h3>Detailed Metrics Table</h3>
                            <div id="metricsTable"></div>
                        </div>

                        <div class="chart-container" id="rocContainer" class="hidden">
                            <h3>ROC Curves</h3>
                            <canvas id="rocChart"></canvas>
                        </div>

                        <div style="margin-top: 20px;">
                            <button class="btn" onclick="saveToHistory()">üíæ Save to History</button>
                        </div>
                    </div>

                    <div id="welcomeMessage">
                        <div class="section" style="text-align: center; padding: 60px;">
                            <h2 style="font-size: 32px; margin-bottom: 20px;">Welcome to ML Model Platform</h2>
                            <p style="color: #666; font-size: 18px;">
                                Upload your dataset to get started with machine learning model training and evaluation.
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- History Screen -->
            <div id="historyScreen" class="content-area hidden" style="width: 100%;">
                <h2 style="color: #667eea; margin-bottom: 30px; font-size: 28px;">üìö Training History</h2>
                <div id="historyContainer"></div>
            </div>
        </div>
    </div>

    <script>
        // LocalStorage Keys
        const USERS_KEY = 'ml_platform_users';
        const HISTORY_KEY = 'ml_platform_history';

        // LocalStorage Functions
        function loadUsers() {
            try {
                const users = localStorage.getItem(USERS_KEY);
                return users ? JSON.parse(users) : {};
            } catch (e) {
                console.error('Error loading users:', e);
                return {};
            }
        }

        function saveUsers(users) {
            try {
                localStorage.setItem(USERS_KEY, JSON.stringify(users));
                return true;
            } catch (e) {
                console.error('Error saving users:', e);
                alert('Error saving user data. Please check your browser storage.');
                return false;
            }
        }

        function loadHistory() {
            try {
                const history = localStorage.getItem(HISTORY_KEY);
                return history ? JSON.parse(history) : {};
            } catch (e) {
                console.error('Error loading history:', e);
                return {};
            }
        }

        function saveHistoryData(history) {
            try {
                localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
                return true;
            } catch (e) {
                console.error('Error saving history:', e);
                alert('Error saving history. Storage might be full.');
                return false;
            }
        }

        // Global Variables
        let currentUser = null;
        let dataset = null;
        let targetColumn = null;
        let selectedModels = new Set();
        let trainedResults = {};
        let currentDatasetName = '';
        let currentTaskType = '';

        // Authentication Functions
        function showLogin() {
            document.getElementById('loginForm').classList.remove('hidden');
            document.getElementById('signupForm').classList.add('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('signupError').classList.add('hidden');
            document.getElementById('signupSuccess').classList.add('hidden');
        }

        function showSignup() {
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('signupForm').classList.remove('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('signupError').classList.add('hidden');
            document.getElementById('signupSuccess').classList.add('hidden');
        }

        function signup() {
            const username = document.getElementById('signupUsername').value.trim();
            const password = document.getElementById('signupPassword').value;
            const confirmPassword = document.getElementById('signupConfirmPassword').value;
            const errorDiv = document.getElementById('signupError');
            const successDiv = document.getElementById('signupSuccess');

            errorDiv.classList.add('hidden');
            successDiv.classList.add('hidden');

            if (!username || !password) {
                errorDiv.textContent = 'Please fill in all fields';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (username.length < 3) {
                errorDiv.textContent = 'Username must be at least 3 characters';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (password.length < 6) {
                errorDiv.textContent = 'Password must be at least 6 characters';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (password !== confirmPassword) {
                errorDiv.textContent = 'Passwords do not match';
                errorDiv.classList.remove('hidden');
                return;
            }

            const users = loadUsers();
            
            if (users[username]) {
                errorDiv.textContent = 'Username already exists';
                errorDiv.classList.remove('hidden');
                return;
            }

            // Create new user
            users[username] = { 
                password: password, 
                createdAt: new Date().toISOString() 
            };
            
            if (!saveUsers(users)) {
                return;
            }

            // Initialize history for new user
            const history = loadHistory();
            history[username] = [];
            saveHistoryData(history);

            // Show success message
            successDiv.textContent = 'Account created successfully! You can now login.';
            successDiv.classList.remove('hidden');

            // Clear form
            document.getElementById('signupUsername').value = '';
            document.getElementById('signupPassword').value = '';
            document.getElementById('signupConfirmPassword').value = '';

            // Switch to login after 2 seconds
            setTimeout(() => {
                showLogin();
            }, 2000);
        }

        function login() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');

            errorDiv.classList.add('hidden');

            if (!username || !password) {
                errorDiv.textContent = 'Please enter username and password';
                errorDiv.classList.remove('hidden');
                return;
            }

            const users = loadUsers();
            
            if (!users[username]) {
                errorDiv.textContent = 'User not found. Please create an account.';
                errorDiv.classList.remove('hidden');
                return;
            }

            if (users[username].password !== password) {
                errorDiv.textContent = 'Incorrect password';
                errorDiv.classList.remove('hidden');
                return;
            }

            // Login successful
            currentUser = username;
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            document.getElementById('userDisplay').textContent = `üë§ ${username}`;
            document.getElementById('loginUsername').value = '';
            document.getElementById('loginPassword').value = '';
            showScreen('train');
        }

        function logout() {
            currentUser = null;
            dataset = null;
            selectedModels.clear();
            trainedResults = {};
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('mainApp').classList.add('hidden');
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('welcomeMessage').classList.remove('hidden');
            showLogin();
        }

        // Screen Navigation
        function showScreen(screen) {
            const trainScreen = document.getElementById('trainScreen');
            const historyScreen = document.getElementById('historyScreen');
            const trainNavBtn = document.getElementById('trainNavBtn');
            const historyNavBtn = document.getElementById('historyNavBtn');

            if (screen === 'train') {
                trainScreen.classList.remove('hidden');
                historyScreen.classList.add('hidden');
                trainNavBtn.classList.add('active');
                historyNavBtn.classList.remove('active');
            } else if (screen === 'history') {
                trainScreen.classList.add('hidden');
                historyScreen.classList.remove('hidden');
                trainNavBtn.classList.remove('active');
                historyNavBtn.classList.add('active');
                displayHistory();
            }
        }

        // File Upload
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            currentDatasetName = file.name;
            const reader = new FileReader();
            
            reader.onload = async function(e) {
                try {
                    let data;
                    const filename = file.name.toLowerCase();

                    if (filename.endsWith('.csv') || filename.endsWith('.txt')) {
                        const text = e.target.result;
                        const parsed = Papa.parse(text, { 
                            header: true, 
                            dynamicTyping: true, 
                            skipEmptyLines: true 
                        });
                        data = parsed.data;
                    } else if (filename.endsWith('.xlsx') || filename.endsWith('.xls')) {
                        const workbook = XLSX.read(e.target.result, { type: 'binary' });
                        const sheetName = workbook.SheetNames[0];
                        data = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
                    }

                    if (data && data.length > 0) {
                        dataset = data;
                        displayDatasetInfo();
                        populateTargetSelect();
                        document.getElementById('welcomeMessage').classList.add('hidden');
                    }
                } catch (error) {
                    alert('Error parsing file: ' + error.message);
                }
            };

            if (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')) {
                reader.readAsBinaryString(file);
            } else {
                reader.readAsText(file);
            }
        }

        function displayDatasetInfo() {
            const info = document.getElementById('datasetInfo');
            const columns = Object.keys(dataset[0]);
            info.innerHTML = `
                <div class="dataset-info">
                    <p><strong>File:</strong> ${currentDatasetName}</p>
                    <p><strong>Rows:</strong> ${dataset.length}</p>
                    <p><strong>Columns:</strong> ${columns.length}</p>
                    <p><strong>Features:</strong> ${columns.slice(0, 3).join(', ')}${columns.length > 3 ? '...' : ''}</p>
                </div>
            `;
            info.classList.remove('hidden');
        }

        function populateTargetSelect() {
            const select = document.getElementById('targetSelect');
            const columns = Object.keys(dataset[0]);
            select.innerHTML = '<option value="">Select target column</option>';
            columns.forEach(col => {
                select.innerHTML += `<option value="${col}">${col}</option>`;
            });
        }

        function updateTargetVariable() {
            targetColumn = document.getElementById('targetSelect').value;
            updateTrainButton();
        }

        function toggleModel(element) {
            const model = element.dataset.model;
            if (selectedModels.has(model)) {
                selectedModels.delete(model);
                element.classList.remove('selected');
            } else {
                selectedModels.add(model);
                element.classList.add('selected');
            }

            if (model === 'nn') {
                document.getElementById('nnConfig').classList.toggle('hidden', !selectedModels.has('nn'));
            }

            updateTrainButton();
        }

        function updateTrainButton() {
            const btn = document.getElementById('trainBtn');
            btn.disabled = !(dataset && targetColumn && selectedModels.size > 0);
        }

        // Loading Screen
        function showLoading() {
            document.getElementById('loadingScreen').classList.remove('hidden');
            updateProgress(0, 'Initializing...');
        }

        function hideLoading() {
            document.getElementById('loadingScreen').classList.add('hidden');
        }

        function updateProgress(percentage, status) {
            const progressBar = document.getElementById('trainingProgress');
            const statusText = document.getElementById('loadingStatus');
            progressBar.style.width = percentage + '%';
            progressBar.textContent = Math.round(percentage) + '%';
            statusText.textContent = status;
        }

        // Model Training
        async function trainModels() {
            showLoading();
            document.getElementById('resultsSection').classList.remove('hidden');
            document.getElementById('welcomeMessage').classList.add('hidden');
            
            trainedResults = {};
            const X = prepareFeatures();
            const y = prepareTarget();
            const isClassification = isClassificationTask(y);
            currentTaskType = isClassification ? 'classification' : 'regression';

            const modelArray = Array.from(selectedModels);
            const totalModels = modelArray.length;

            for (let i = 0; i < totalModels; i++) {
                const model = modelArray[i];
                const progress = ((i / totalModels) * 100);
                
                try {
                    let modelName = getModelName(model);
                    updateProgress(progress, `Training ${modelName}...`);
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    let result;
                    switch(model) {
                        case 'linear':
                            result = await trainLinearRegression(X, y);
                            break;
                        case 'logistic':
                            result = await trainLogisticRegression(X, y);
                            break;
                        case 'decision':
                            result = await trainDecisionTree(X, y, isClassification);
                            break;
                        case 'randomforest':
                            result = await trainRandomForest(X, y, isClassification);
                            break;
                        case 'svm':
                            result = await trainSVM(X, y, isClassification);
                            break;
                        case 'nn':
                            result = await trainNeuralNetwork(X, y, isClassification);
                            break;
                    }
                    trainedResults[model] = result;
                } catch (error) {
                    console.error(`Error training ${model}:`, error);
                }
            }

            updateProgress(100, 'Training complete!');
            await new Promise(resolve => setTimeout(resolve, 500));
            hideLoading();
            displayResults(isClassification);
        }

        function getModelName(model) {
            const names = {
                'linear': 'Linear Regression',
                'logistic': 'Logistic Regression',
                'decision': 'Decision Tree',
                'randomforest': 'Random Forest',
                'svm': 'SVM',
                'nn': 'Neural Network'
            };
            return names[model] || model;
        }

        function prepareFeatures() {
            const features = [];
            const columns = Object.keys(dataset[0]).filter(col => col !== targetColumn);
            
            dataset.forEach(row => {
                const featureRow = columns.map(col => {
                    const val = row[col];
                    return typeof val === 'number' ? val : 0;
                });
                features.push(featureRow);
            });
            
            return normalize(features);
        }

        function prepareTarget() {
            return dataset.map(row => row[targetColumn]);
        }

        function isClassificationTask(y) {
            const uniqueValues = [...new Set(y)];
            return uniqueValues.length < 20 && uniqueValues.every(v => Number.isInteger(v) || typeof v === 'string');
        }

        function normalize(data) {
            const normalized = [];
            const numFeatures = data[0].length;
            
            for (let j = 0; j < numFeatures; j++) {
                const column = data.map(row => row[j]);
                const min = Math.min(...column);
                const max = Math.max(...column);
                const range = max - min || 1;
                
                for (let i = 0; i < data.length; i++) {
                    if (!normalized[i]) normalized[i] = [];
                    normalized[i][j] = (data[i][j] - min) / range;
                }
            }
            
            return normalized;
        }

        // ML Model Implementations (simplified for demo)
        async function trainLinearRegression(X, y) {
            const n = X.length;
            const m = X[0].length;
            let weights = new Array(m).fill(0);
            let bias = 0;
            const lr = 0.01;
            const epochs = 1000;

            for (let epoch = 0; epoch < epochs; epoch++) {
                let predictions = X.map(x => x.reduce((sum, val, j) => sum + val * weights[j], bias));
                const errors = predictions.map((pred, i) => pred - y[i]);
                
                weights = weights.map((w, j) => {
                    const gradient = errors.reduce((sum, err, i) => sum + err * X[i][j], 0) / n;
                    return w - lr * gradient;
                });

                bias -= lr * errors.reduce((a, b) => a + b, 0) / n;
            }

            const predictions = X.map(x => x.reduce((sum, val, j) => sum + val * weights[j], bias));
            return calculateRegressionMetrics(y, predictions, 'Linear Regression');
        }

        async function trainLogisticRegression(X, y) {
            const yBinary = y.map(val => val > 0 ? 1 : 0);
            const n = X.length;
            const m = X[0].length;
            let weights = new Array(m).fill(0);
            let bias = 0;
            const lr = 0.1;
            const epochs = 1000;

            const sigmoid = z => 1 / (1 + Math.exp(-z));

            for (let epoch = 0; epoch < epochs; epoch++) {
                const predictions = X.map(x => {
                    const z = x.reduce((sum, val, j) => sum + val * weights[j], bias);
                    return sigmoid(z);
                });

                const errors = predictions.map((pred, i) => pred - yBinary[i]);
                
                weights = weights.map((w, j) => {
                    const gradient = errors.reduce((sum, err, i) => sum + err * X[i][j], 0) / n;
                    return w - lr * gradient;
                });

                bias -= lr * errors.reduce((a, b) => a + b, 0) / n;
            }

            const probabilities = X.map(x => {
                const z = x.reduce((sum, val, j) => sum + val * weights[j], bias);
                return sigmoid(z);
            });
            const predictions = probabilities.map(p => p > 0.5 ? 1 : 0);
            
            return calculateClassificationMetrics(yBinary, predictions, probabilities, 'Logistic Regression');
        }

        async function trainDecisionTree(X, y, isClassification) {
            const predictions = y.map(() => {
                const mean = y.reduce((a, b) => a + b, 0) / y.length;
                return isClassification ? Math.round(mean) : mean;
            });

            if (isClassification) {
                const yBinary = y.map(val => val > 0 ? 1 : 0);
                const predBinary = predictions.map(val => val > 0 ? 1 : 0);
                return calculateClassificationMetrics(yBinary, predBinary, predictions.map(() => 0.5), 'Decision Tree');
            } else {
                return calculateRegressionMetrics(y, predictions, 'Decision Tree');
            }
        }

        async function trainRandomForest(X, y, isClassification) {
            const numTrees = 10;
            const allPredictions = [];

            for (let t = 0; t < numTrees; t++) {
                const indices = Array.from({length: X.length}, () => Math.floor(Math.random() * X.length));
                const treeY = indices.map(i => y[i]);
                const mean = treeY.reduce((a, b) => a + b, 0) / treeY.length;
                allPredictions.push(Array(X.length).fill(isClassification ? Math.round(mean) : mean));
            }

            const predictions = X.map((_, i) => {
                const treePreds = allPredictions.map(preds => preds[i]);
                return treePreds.reduce((a, b) => a + b, 0) / numTrees;
            });

            if (isClassification) {
                const yBinary = y.map(val => val > 0 ? 1 : 0);
                const predBinary = predictions.map(val => Math.round(val));
                return calculateClassificationMetrics(yBinary, predBinary, predictions, 'Random Forest');
            } else {
                return calculateRegressionMetrics(y, predictions, 'Random Forest');
            }
        }

        async function trainSVM(X, y, isClassification) {
            const yBinary = y.map(val => val > 0 ? 1 : -1);
            const n = X.length;
            const m = X[0].length;
            let weights = new Array(m).fill(0);
            let bias = 0;
            const lr = 0.001;
            const lambda = 0.01;
            const epochs = 1000;

            for (let epoch = 0; epoch < epochs; epoch++) {
                for (let i = 0; i < n; i++) {
                    const score = X[i].reduce((sum, val, j) => sum + val * weights[j], bias);
                    if (yBinary[i] * score < 1) {
                        weights = weights.map((w, j) => w - lr * (2 * lambda * w - yBinary[i] * X[i][j]));
                        bias -= lr * (-yBinary[i]);
                    } else {
                        weights = weights.map(w => w - lr * 2 * lambda * w);
                    }
                }
            }

            const scores = X.map(x => x.reduce((sum, val, j) => sum + val * weights[j], bias));
            const predictions = scores.map(s => s > 0 ? 1 : 0);
            const yBinaryPos = yBinary.map(v => v === 1 ? 1 : 0);
            
            return calculateClassificationMetrics(yBinaryPos, predictions, scores, 'SVM');
        }

        async function trainNeuralNetwork(X, y, isClassification) {
            const layers = document.getElementById('nnLayers').value.split(',').map(n => parseInt(n.trim()));
            const epochs = parseInt(document.getElementById('nnEpochs').value);
            const learningRate = parseFloat(document.getElementById('nnLR').value);

            const inputSize = X[0].length;
            const model = tf.sequential();
            model.add(tf.layers.dense({ units: layers[0], activation: 'relu', inputShape: [inputSize] }));
            
            for (let i = 1; i < layers.length; i++) {
                model.add(tf.layers.dense({ units: layers[i], activation: 'relu' }));
            }

            model.add(tf.layers.dense({ 
                units: 1, 
                activation: isClassification ? 'sigmoid' : 'linear' 
            }));

            model.compile({
                optimizer: tf.train.adam(learningRate),
                loss: isClassification ? 'binaryCrossentropy' : 'meanSquaredError',
                metrics: ['accuracy']
            });

            const xs = tf.tensor2d(X);
            const yBinary = isClassification ? y.map(val => val > 0 ? 1 : 0) : y;
            const ys = tf.tensor2d(yBinary, [yBinary.length, 1]);

            await model.fit(xs, ys, { epochs: epochs, verbose: 0 });

            const predictions = model.predict(xs);
            const predArray = await predictions.data();
            
            xs.dispose();
            ys.dispose();
            predictions.dispose();

            if (isClassification) {
                const predBinary = Array.from(predArray).map(p => p > 0.5 ? 1 : 0);
                return calculateClassificationMetrics(yBinary, predBinary, Array.from(predArray), 'Neural Network');
            } else {
                return calculateRegressionMetrics(y, Array.from(predArray), 'Neural Network');
            }
        }

        function calculateRegressionMetrics(yTrue, yPred, modelName) {
            const n = yTrue.length;
            const mse = yTrue.reduce((sum, val, i) => sum + Math.pow(val - yPred[i], 2), 0) / n;
            const rmse = Math.sqrt(mse);
            
            const yMean = yTrue.reduce((a, b) => a + b, 0) / n;
            const ssTot = yTrue.reduce((sum, val) => sum + Math.pow(val - yMean, 2), 0);
            const ssRes = yTrue.reduce((sum, val, i) => sum + Math.pow(val - yPred[i], 2), 0);
            const r2 = 1 - (ssRes / ssTot);
            
            const mae = yTrue.reduce((sum, val, i) => sum + Math.abs(val - yPred[i]), 0) / n;

            return {
                modelName,
                type: 'regression',
                metrics: {
                    mse: mse.toFixed(4),
                    rmse: rmse.toFixed(4),
                    r2: r2.toFixed(4),
                    mae: mae.toFixed(4)
                }
            };
        }

        function calculateClassificationMetrics(yTrue, yPred, yProb, modelName) {
            let tp = 0, tn = 0, fp = 0, fn = 0;

            for (let i = 0; i < yTrue.length; i++) {
                if (yTrue[i] === 1 && yPred[i] === 1) tp++;
                else if (yTrue[i] === 0 && yPred[i] === 0) tn++;
                else if (yTrue[i] === 0 && yPred[i] === 1) fp++;
                else if (yTrue[i] === 1 && yPred[i] === 0) fn++;
            }

            const accuracy = (tp + tn) / (tp + tn + fp + fn);
            const precision = tp / (tp + fp) || 0;
            const recall = tp / (tp + fn) || 0;
            const f1 = 2 * (precision * recall) / (precision + recall) || 0;

            const rocData = calculateROC(yTrue, yProb);

            return {
                modelName,
                type: 'classification',
                metrics: {
                    accuracy: accuracy.toFixed(4),
                    precision: precision.toFixed(4),
                    recall: recall.toFixed(4),
                    f1: f1.toFixed(4),
                    auc: rocData.auc.toFixed(4)
                },
                rocData: rocData
            };
        }

        function calculateROC(yTrue, yProb) {
            const points = yTrue.map((label, i) => ({ label, prob: yProb[i] }))
                .sort((a, b) => b.prob - a.prob);

            const rocPoints = [];
            let tp = 0, fp = 0;
            const totalPositive = yTrue.filter(y => y === 1).length;
            const totalNegative = yTrue.length - totalPositive;

            rocPoints.push({ fpr: 0, tpr: 0 });

            points.forEach(point => {
                if (point.label === 1) tp++;
                else fp++;

                const tpr = tp / totalPositive;
                const fpr = fp / totalNegative;
                rocPoints.push({ fpr, tpr });
            });

            let auc = 0;
            for (let i = 1; i < rocPoints.length; i++) {
                const width = rocPoints[i].fpr - rocPoints[i-1].fpr;
                const height = (rocPoints[i].tpr + rocPoints[i-1].tpr) / 2;
                auc += width * height;
            }

            return { points: rocPoints, auc };
        }

        // Display Results
        function displayResults(isClassification) {
            const metricsGrid = document.getElementById('metricsGrid');
            metricsGrid.innerHTML = '';

            const modelNames = Object.keys(trainedResults);
            
            modelNames.forEach(model => {
                const result = trainedResults[model];
                const metrics = result.metrics;
                
                if (isClassification) {
                    metricsGrid.innerHTML += `
                        <div class="metric-card">
                            <h3>${result.modelName}</h3>
                            <div class="value">${(parseFloat(metrics.accuracy) * 100).toFixed(1)}%</div>
                            <p style="margin-top: 10px; font-size: 14px;">Accuracy</p>
                        </div>
                    `;
                } else {
                    metricsGrid.innerHTML += `
                        <div class="metric-card">
                            <h3>${result.modelName}</h3>
                            <div class="value">${metrics.r2}</div>
                            <p style="margin-top: 10px; font-size: 14px;">R¬≤ Score</p>
                        </div>
                    `;
                }
            });

            displayComparisonChart(isClassification);
            displayMetricsTable(isClassification);
            
            if (isClassification) {
                displayROCCurves();
            }
        }

        function displayComparisonChart(isClassification) {
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            const modelNames = Object.keys(trainedResults);
            
            if (window.comparisonChartInstance) {
                window.comparisonChartInstance.destroy();
            }

            if (isClassification) {
                const accuracies = modelNames.map(m => parseFloat(trainedResults[m].metrics.accuracy) * 100);
                const precisions = modelNames.map(m => parseFloat(trainedResults[m].metrics.precision) * 100);
                const recalls = modelNames.map(m => parseFloat(trainedResults[m].metrics.recall) * 100);

                window.comparisonChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: modelNames.map(m => trainedResults[m].modelName),
                        datasets: [
                            {
                                label: 'Accuracy',
                                data: accuracies,
                                backgroundColor: 'rgba(102, 126, 234, 0.8)'
                            },
                            {
                                label: 'Precision',
                                data: precisions,
                                backgroundColor: 'rgba(118, 75, 162, 0.8)'
                            },
                            {
                                label: 'Recall',
                                data: recalls,
                                backgroundColor: 'rgba(237, 100, 166, 0.8)'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                ticks: {
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                const r2Scores = modelNames.map(m => parseFloat(trainedResults[m].metrics.r2));
                const rmseScores = modelNames.map(m => parseFloat(trainedResults[m].metrics.rmse));

                window.comparisonChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: modelNames.map(m => trainedResults[m].modelName),
                        datasets: [
                            {
                                label: 'R¬≤ Score',
                                data: r2Scores,
                                backgroundColor: 'rgba(102, 126, 234, 0.8)',
                                yAxisID: 'y'
                            },
                            {
                                label: 'RMSE',
                                data: rmseScores,
                                backgroundColor: 'rgba(237, 100, 166, 0.8)',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'R¬≤ Score'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'RMSE'
                                },
                                grid: {
                                    drawOnChartArea: false
                                }
                            }
                        }
                    }
                });
            }
        }

        function displayMetricsTable(isClassification) {
            const tableDiv = document.getElementById('metricsTable');
            const modelNames = Object.keys(trainedResults);
            
            let tableHTML = '<table><thead><tr><th>Model</th>';
            
            if (isClassification) {
                tableHTML += '<th>Accuracy</th><th>Precision</th><th>Recall</th><th>F1 Score</th><th>AUC</th>';
            } else {
                tableHTML += '<th>R¬≤ Score</th><th>RMSE</th><th>MSE</th><th>MAE</th>';
            }
            
            tableHTML += '</tr></thead><tbody>';
            
            modelNames.forEach(model => {
                const result = trainedResults[model];
                const metrics = result.metrics;
                
                tableHTML += `<tr><td><strong>${result.modelName}</strong></td>`;
                
                if (isClassification) {
                    tableHTML += `
                        <td>${(parseFloat(metrics.accuracy) * 100).toFixed(2)}%</td>
                        <td>${(parseFloat(metrics.precision) * 100).toFixed(2)}%</td>
                        <td>${(parseFloat(metrics.recall) * 100).toFixed(2)}%</td>
                        <td>${(parseFloat(metrics.f1) * 100).toFixed(2)}%</td>
                        <td>${metrics.auc}</td>
                    `;
                } else {
                    tableHTML += `
                        <td>${metrics.r2}</td>
                        <td>${metrics.rmse}</td>
                        <td>${metrics.mse}</td>
                        <td>${metrics.mae}</td>
                    `;
                }
                
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            tableDiv.innerHTML = tableHTML;
        }

        function displayROCCurves() {
            const rocContainer = document.getElementById('rocContainer');
            rocContainer.classList.remove('hidden');
            
            const ctx = document.getElementById('rocChart').getContext('2d');
            const modelNames = Object.keys(trainedResults);
            
            if (window.rocChartInstance) {
                window.rocChartInstance.destroy();
            }

            const datasets = modelNames.map((model, idx) => {
                const result = trainedResults[model];
                if (!result.rocData) return null;
                
                const colors = [
                    'rgba(102, 126, 234, 1)',
                    'rgba(118, 75, 162, 1)',
                    'rgba(237, 100, 166, 1)',
                    'rgba(76, 209, 55, 1)',
                    'rgba(255, 152, 0, 1)',
                    'rgba(233, 30, 99, 1)'
                ];

                return {
                    label: `${result.modelName} (AUC: ${result.metrics.auc})`,
                    data: result.rocData.points.map(p => ({ x: p.fpr, y: p.tpr })),
                    borderColor: colors[idx % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                };
            }).filter(d => d !== null);

            datasets.push({
                label: 'Random Classifier',
                data: [{ x: 0, y: 0 }, { x: 1, y: 1 }],
                borderColor: 'rgba(158, 158, 158, 0.5)',
                borderDash: [5, 5],
                backgroundColor: 'transparent',
                borderWidth: 2,
                pointRadius: 0
            });

            window.rocChartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'False Positive Rate'
                            },
                            min: 0,
                            max: 1
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'True Positive Rate'
                            },
                            min: 0,
                            max: 1
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        // History Management
        function saveToHistory() {
            if (!currentUser || !trainedResults || Object.keys(trainedResults).length === 0) {
                alert('No results to save!');
                return;
            }

            const historyEntry = {
                id: Date.now(),
                timestamp: new Date().toLocaleString(),
                datasetName: currentDatasetName,
                targetColumn: targetColumn,
                models: Array.from(selectedModels),
                results: JSON.parse(JSON.stringify(trainedResults)),
                datasetRows: dataset.length,
                datasetCols: Object.keys(dataset[0]).length,
                taskType: currentTaskType
            };

            const history = loadHistory();
            if (!history[currentUser]) {
                history[currentUser] = [];
            }
            history[currentUser].push(historyEntry);
            
            if (saveHistoryData(history)) {
                alert('‚úÖ Results saved to history successfully!');
            }
        }

        function displayHistory() {
            const container = document.getElementById('historyContainer');
            const history = loadHistory();
            const userHistory = history[currentUser] || [];

            if (userHistory.length === 0) {
                container.innerHTML = `
                    <div class="empty-history">
                        <div class="empty-history-icon">üìä</div>
                        <h3>No Training History Yet</h3>
                        <p>Train some models and save them to see your history here.</p>
                    </div>
                `;
                return;
            }

            let historyHTML = '<div class="history-grid">';
            
            [...userHistory].reverse().forEach(entry => {
                const modelNames = entry.models.map(m => getModelName(m));
                
                historyHTML += `
                    <div class="history-card">
                        <div class="history-card-header">
                            <div class="history-card-title">${entry.datasetName}</div>
                            <div class="history-card-date">${entry.timestamp}</div>
                        </div>
                        <div class="history-card-info">
                            <strong>Target:</strong> ${entry.targetColumn}
                        </div>
                        <div class="history-card-info">
                            <strong>Dataset:</strong> ${entry.datasetRows} rows √ó ${entry.datasetCols} columns
                        </div>
                        <div class="history-card-info">
                            <strong>Task:</strong> ${entry.taskType || 'N/A'}
                        </div>
                        <div class="history-card-models">
                            ${modelNames.map(name => `<span class="history-model-badge">${name}</span>`).join('')}
                        </div>
                        <div class="history-card-actions">
                            <button class="history-btn view-btn" onclick="viewHistoryEntry(${entry.id})">View Results</button>
                            <button class="history-btn delete-btn" onclick="deleteHistoryEntry(${entry.id})">Delete</button>
                        </div>
                    </div>
                `;
            });
            
            historyHTML += '</div>';
            container.innerHTML = historyHTML;
        }

        function viewHistoryEntry(id) {
            const history = loadHistory();
            const entry = history[currentUser].find(e => e.id === id);
            if (!entry) {
                alert('Entry not found!');
                return;
            }

            trainedResults = entry.results;
            currentDatasetName = entry.datasetName;
            targetColumn = entry.targetColumn;
            currentTaskType = entry.taskType;
            
            const isClassification = entry.taskType === 'classification';
            
            showScreen('train');
            document.getElementById('resultsSection').classList.remove('hidden');
            document.getElementById('welcomeMessage').classList.add('hidden');
            displayResults(isClassification);
        }

        function deleteHistoryEntry(id) {
            if (!confirm('Are you sure you want to delete this entry?')) {
                return;
            }
            
            const history = loadHistory();
            const index = history[currentUser].findIndex(e => e.id === id);
            
            if (index !== -1) {
                history[currentUser].splice(index, 1);
                if (saveHistoryData(history)) {
                    displayHistory();
                }
            }
        }
    </script>
</body>
</html>